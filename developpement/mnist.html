<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Practical session 1 - AI Frameworks</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/docco.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../index.html">AI Frameworks</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../index.html" class="nav-link">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Courses <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Development tools for Data Scientist</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="pytorch.html" class="dropdown-item">Introduction to Pytorch</a>
</li>
            
<li>
    <a href="git_intro.html" class="dropdown-item">Introduction to Git</a>
</li>
            
<li>
    <a href="docker.html" class="dropdown-item">Introduction to Docker</a>
</li>
            
<li>
    <a href="api.html" class="dropdown-item">Introduction to REST APIs</a>
</li>
            
<li>
    <a href="mnist.html" class="dropdown-item active">Practical session 1</a>
</li>
            
<li>
    <a href="colorize.html" class="dropdown-item">Practical session 2</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../schedule.html" class="nav-link">Schedule</a>
                            </li>
                            <li class="navitem">
                                <a href="https://github.com/DavidBert/AIF2024" class="nav-link">Github repository</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="api.html" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="colorize.html" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#development-for-data-scientist" class="nav-link">Development for Data Scientist:</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#practical-session-1-deploying-a-digit-classifier" class="nav-link">Practical session 1: Deploying a digit classifier</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#practical-session-repository" class="nav-link">Practical session repository:</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#the-network-class" class="nav-link">The network class:</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#the-training-script" class="nav-link">The training script</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#monitoring-and-experiment-management" class="nav-link">Monitoring and experiment management</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#deploying-your-model-with-flask" class="nav-link">Deploying your model with Flask:</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#a-simple-gui-with-tkinter" class="nav-link">A simple GUI with tkinter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#deploying-your-model-with-gradio" class="nav-link">Deploying your model with Gradio</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#git" class="nav-link">Git</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#docker" class="nav-link">Docker</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="development-for-data-scientist">Development for Data Scientist:</h1>
<h2 id="practical-session-1-deploying-a-digit-classifier">Practical session 1: Deploying a digit classifier</h2>
<p>For this session, your task is to create a script for training a simple neural network on the MNIST dataset using PyTorch. Throughout the training process, you'll utilize TensorBoard for the following purposes:</p>
<ul>
<li>Keeping an eye on your network's performance as epochs progress.</li>
<li>Organizing your different experiments and hyperparameters.</li>
<li>Generating visualizations to aid in analysis.</li>
</ul>
<p>Once the training process is complete, you'll also learn how to export your model in a format that can be used for inference.<br />
Finally, you will learn how to deploy your model on a REST API using Flask and how to request it using a Python script.</p>
<!-- The solution is available here.  [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/DavidBert/N7-techno-IA/blob/master/code/developpement/MNIST_solution.ipynb)  
Try to complete the practical session without looking at it! -->

<h2 id="practical-session-repository">Practical session repository:</h2>
<p>If you haven't already done so, create an account on <a href="https://github.com/">Github</a>.
Then fork <a href="https://github.com/DavidBert/ModIA_TP1">this repository</a> and clone it on your computer.<br />
<img alt="" src="../img/code/fork.png" /></p>
<h2 id="the-network-class">The network class:</h2>
<p><img alt="" src="../img/Mnist_net.png" /></p>
<p>Using the figure above, fill in the following code, in the <code>model.py</code> file, to create the network class:  </p>
<ul>
<li>The method <code>__init__()</code> should instantiate all the layers that will be used  by the network.</li>
<li>The method <code>forward()</code> describes the forward graph of your network. All the pooling operations and activation functions are realized in this method. Do not forget to change the shape of your input before the first linear layer using <code>torch.flatten(...)</code> or <code>x.view(...)</code>.</li>
</ul>
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F

class MNISTNet(nn.Module):
    def __init__(self):
        super(MNNISTNet, self).__init__()
        self.conv1 = nn.Conv2d(...)
        self.conv2 = nn.Conv2d(...)
        self.pool = nn.MaxPool2d(...)
        self.fc1 = nn.Linear(...)
        self.fc2 = nn.Linear(...)
        self.fc3 = nn.Linear(...)

    def forward(self, x):
        x = F.relu(self.conv1(x))       # First convolution followed by
        x = self.pool(x)                # a relu activation and a max pooling#
        x = ...
        ...
        x = self.fc3(x)
        return x
</code></pre>
<h2 id="the-training-script">The training script</h2>
<p>The earlier file included your model class.<br />
Now, you will proceed to finalize the training script, named <code>train.py</code>. This script will serve as a Python script for training a neural network on the MNIST Dataset.<br />
Both the <code>train()</code> and <code>test()</code> methods have already been implemented.</p>
<pre><code class="language-python">import argparse
from statistics import mean

import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from tqdm import tqdm

from model import MNISTNet

 # setting device on GPU if available, else CPU
  device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

def train(net, optimizer, loader, epochs=10):
    criterion = nn.CrossEntropyLoss()
    for epoch in range(epochs):
        running_loss = []
        t = tqdm(loader)
        for x, y in t:
            x, y = x.to(device), y.to(device)
            outputs = net(x)
            loss = criterion(outputs, y)
            running_loss.append(loss.item())
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            t.set_description(f'training loss: {mean(running_loss)}')

def test(model, dataloader):
    test_corrects = 0
    total = 0
    with torch.no_grad():
        for x, y in dataloader:
            x = x.to(device)
            y = y.to(device)
            y_hat = model(x).argmax(1)
            test_corrects += y_hat.eq(y).sum().item()
            total += y.size(0)
    return test_corrects / total
</code></pre>
<p>Now you will implement the main method, which will be executed each time the Python script is run. You'd like to offer users the flexibility to adjust certain learning process parameters, specifically:</p>
<ul>
<li>Batch size</li>
<li>Learning rate</li>
<li>Number of training epochs</li>
</ul>
<p>To achieve this, the Python argparse module will be employed. This module simplifies the creation of user-friendly command-line interfaces. Incorporating arguments into a Python script through argparse is a straightforward process. To begin, you'll need to import the argparse module and create a parser instance within the main method:</p>
<pre><code class="language-python">import argparse

if __name__=='__main__':
  parser = argparse.ArgumentParser()
</code></pre>
<p>Then, just add a new argument to the parser precising the argument's name, its type, and optionaly a default value and an helping message.</p>
<pre><code class="language-python">  parser.add_argument('--exp_name', type=str, default = 'MNIST', help='experiment name')
</code></pre>
<p>Finaly, you can use the arguments as follows:</p>
<pre><code class="language-python">  args = parser.parse_args()
  print(args.exp_name)
</code></pre>
<p>Complete the main method to parse the four possible arguments provided when executing the script:</p>
<pre><code class="language-python">if __name__=='__main__':

  parser = argparse.ArgumentParser()

  parser.add_argument('--exp_name', type=str, default = 'MNIST', help='experiment name')
  parser.add_argument(...)
  parser.add_argument(...)
  parser.add_argument(...)

  args = parser.parse_args()
  exp_name = args.exp_name
  epochs = ...
  batch_size = ...
  lr = ...
</code></pre>
<p>The following code instantiates two <a href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html">data loaders</a>: one loading data from the training set, the other one from the test set.</p>
<pre><code class="language-python"># transforms
  transform = transforms.Compose(
      [transforms.ToTensor(),
      transforms.Normalize((0.5,), (0.5,))])

  # datasets
  trainset = torchvision.datasets.MNIST('./data', download=True, train=True, transform=transform)
  testset = torchvision.datasets.MNIST('./data', download=True, train=False, transform=transform)

  # dataloaders
  trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size, shuffle=True, num_workers=2)
  testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size, shuffle=False, num_workers=2)
</code></pre>
<p>Instantiate a MNISTNet and a <a href="https://pytorch.org/docs/stable/generated/torch.optim.SGD.html">SGD optimizer</a> using the learning rate provided in the script arguments.<br />
Call the train method to train your network and the test method to evaluate it.<br />
Finally, print the test accuracy. </p>
<pre><code class="language-python">  net = ...
  # setting net on device(GPU if available, else CPU)
  net = net.to(device)
  optimizer = optim.SGD(...)

  train(...)
  test_acc = test(...)
  print(f'Test accuracy:{test_acc}')
</code></pre>
<p>Save your model using the <code>torch.save</code> method.<br />
This method takes two arguments: the first one is the object to save, the second one is the path to the file where the object will be saved. 
Here, you will save the model's state dictionary (<code>net.state_dict()</code>) in a file named <code>mnist_net.pth</code>.<br />
The state dictionary is a Python dictionary containing all the weights and biases of the network.</p>
<pre><code class="language-python">  torch.save(net.state_dict(), 'mnist_net.pth')
</code></pre>
<p>You should now be able to run your python script using the following command in your terminal:</p>
<pre><code>python train.py --epochs=5 --lr=1e-3 --batch_size=64
</code></pre>
<h2 id="monitoring-and-experiment-management">Monitoring and experiment management</h2>
<p>Training our model on MNIST is pretty fast.
Nonetheless, in most cases, training a network may be very long.
For such cases, it is essential to log partial results during training to ensure that everything is behaving as expected.<br />
A very famous tool to monitor your experiments in deep learning is Tensorboard.<br />
The main object used by Tensorboard is a <code>SummaryWriter</code>.<br />
Add the following import:</p>
<pre><code class="language-python">from torch.utils.tensorboard import SummaryWriter
</code></pre>
<p>and modify the train method to take an additional argument named <code>writer</code>. Use its <code>add_scalar</code> method to log the training loss for every epoch.</p>
<pre><code class="language-python">def train(net, optimizer, loader, writer, epochs=10):
    criterion = nn.CrossEntropyLoss()
    for epoch in range(epochs):
        running_loss = []
        t = tqdm(loader)
        for x, y in t:
            x, y = x.to(device), y.to(device)
            outputs = net(x)
            loss = criterion(outputs, y)
            running_loss.append(loss.item())
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            t.set_description(f'training loss: {mean(running_loss)}')
        writer.add_scalar('training loss', mean(running_loss), epoch)
</code></pre>
<p>In the <code>main</code> method instantiate a <code>SummaryWriter</code> with </p>
<pre><code class="language-python">writer = SummaryWriter(f'runs/MNIST')
</code></pre>
<p>and add it as argument to the <code>train</code> method.<br />
Re-run your script and check your tensorboard logs using in a separate terminal:</p>
<pre><code class="language-bash">tensorboard --logdir runs
</code></pre>
<p>You can use tensorboard to log many different things such as your network computational graph, images, samples from your dataset, embeddings, or even use it for experiment management.  </p>
<p>Add a new method to the MNISTNet class to get the embeddings computed after the last convolutional layer.</p>
<pre><code class="language-python">def get_features(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, 16 * 4 * 4)
        return x
</code></pre>
<p>Now these following code to the end of your <code>main</code> function to log the embeddings and the computational graph in tensorboard. </p>
<pre><code class="language-python">  #add embeddings to tensorboard
  perm = torch.randperm(len(trainset.data))
  images, labels = trainset.data[perm][:256], trainset.targets[perm][:256]
  images = images.unsqueeze(1).float().to(device)
  with torch.no_grad():
    embeddings = net.get_features(images)
    writer.add_embedding(embeddings,
                  metadata=labels,
                  label_img=images, global_step=1)

  # save networks computational graph in tensorboard
  writer.add_graph(net, images)
  # save a dataset sample in tensorboard
  img_grid = torchvision.utils.make_grid(images[:64])
  writer.add_image('mnist_images', img_grid)
</code></pre>
<p>Re-run your script and restart tensorboard. <br />
Visualize the network computational graph by clicking on <strong>Graph</strong>.<br />
You should see something similar to this:
<img alt="" src="../img/tensorboard_2.png" /></p>
<p>Click on the <strong>inactive</strong> button and choose <strong>projector</strong> to look at the embeddings computed by your network
<img alt="" src="../img/tensorboard_3.png" />
<img alt="" src="../img/tensorboard_4.png" />
<img alt="" src="../img/tensorboard_6.png" /></p>
<h2 id="deploying-your-model-with-flask">Deploying your model with Flask:</h2>
<p>Now that your model is trained, you will deploy it using a simple Flask application.<br />
Flask is a micro web framework written in Python. It is classified as a microframework because it does not require particular tools or libraries. 
The following code is a simple Flask application that will load your model and given an image, it will return the predicted class.
The application will listen on port 5000 and will have a single route <code>/predict</code> that will accept a POST request with an image as payload.
The image will be received as a byte stream and will first be converted to a PIL image, then will be transformed using the same transformation as during training to be fed to the model.<br />
The model will return a tensor containing the probabilities for each class. The class with the highest probability will be returned as a JSON object.  </p>
<p>Complete the following code to take the path of your model as an argument and load it in the <code>model</code> variable. </p>
<pre><code class="language-python">  import argparse
  import torch
  import torchvision.transforms as transforms
  from flask import Flask, jsonify, request
  from PIL import Image
  import io
  from models import MNISTNet

  device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

  app = Flask(__name__)

  parser = ...
  ...
  model_path = ...

  model = MNISTNet().to(device)
  # Load the model
  model.load_state_dict(torch.load(model_path))
  model.eval()

  transform = transforms.Compose([
      transforms.Resize((28, 28)),
      transforms.ToTensor(),
      transforms.Normalize((0.5,), (0.5,))
  ])

  @app.route('/predict', methods=['POST'])
  def predict():
      img_binary = request.data
      img_pil = Image.open(io.BytesIO(img_binary))

      # Transform the PIL image
      tensor = transform(img_pil).to(device)
      tensor = tensor.unsqueeze(0)  # Add batch dimension

      # Make prediction
      with torch.no_grad():
          outputs = model(tensor)
          _, predicted = outputs.max(1)

      return jsonify({&quot;prediction&quot;: int(predicted[0])})

      if __name__ == &quot;__main__&quot;:
        app.run(debug=True)
</code></pre>
<p>Save the code in a file named <code>mnist_api.py</code> and run it with:</p>
<pre><code class="language-bash">python mnist_api.py --model_path [PATH_TO_YOUR_MODEL]
</code></pre>
<p>Now run the <code>test_api.ipynb</code> notebook to test your API.</p>
<p>We requested the api one image at a time. As you may already know, neural networks are much more efficient when they are fed with a batch of images.<br />
Modify the <code>mnist_api.py</code> by adding a new route <code>/batch_predict</code> that will accept a batch of images and return a batch of predictions and test it with the last cell of the <code>test_api.ipynb</code> notebook.</p>
<h2 id="a-simple-gui-with-tkinter">A simple GUI with tkinter</h2>
<p>The file <code>mnist_gui.py</code> contains a simple GUI that will allow you to draw a digit and send it to the API to get a prediction.
Run the script with:</p>
<pre><code class="language-bash">python mnist_gui.py --model_path [PATH_TO_YOUR_MODEL]
</code></pre>
<p>and provide some of the images in the <code>MNIST_sample</code> folder as input to your model.</p>
<h2 id="deploying-your-model-with-gradio">Deploying your model with Gradio</h2>
<p>As you can see, the GUI is very simple and not very user friendly.
<a href="https://gradio.app/">Gradio</a> is a library that allows you to quickly create a user friendly web interface for your model. </p>
<p>Install the library:</p>
<pre><code class="language-bash">pip install gradio
</code></pre>
<p>Creating an application with Gradio is done through the use of its Interface class
The core Interface class is initialized with three required parameters:</p>
<ul>
<li>fn: the function to wrap a user interface around</li>
<li>inputs: which component(s) to use for the input, e.g. "text" or "image" or "audio"</li>
<li>outputs: which component(s) to use for the output, e.g. "text" or "image" "label"</li>
</ul>
<p>Gradio includes more than <a href="https://gradio.app/docs/#components">20 different components</a>, most of which can be used as inputs or outputs.</p>
<p>In this example, we will use a <em>sketchpad</em> (which is an instance of the <a href="https://gradio.app/docs/#image"><em>Image</em> component</a>)component for the input and a <a href="https://gradio.app/docs/#label"><em>Label</em> component</a>  for the output.</p>
<pre><code class="language-python">gr.Interface(fn=recognize_digit, 
            inputs=&quot;sketchpad&quot;, 
            outputs='label',
            live=True,
            description=&quot;Draw a number on the sketchpad to see the model's prediction.&quot;,
            ).launch(debug=True, share=True);
</code></pre>
<p>Complete the <code>mnist_app.py</code> to either load your model weights or use your api to perform the predictions and run your app with the following command:</p>
<pre><code class="language-bash">python mnist_app.py --weights_path [path_to_the weights]
</code></pre>
<p>Is your model accurate with your drawings?
Do you know why it is less accurate than on MNIST?</p>
<h2 id="git">Git</h2>
<p>Commit all the modifications you have made to the repository as well as the weights and push them to your remote repository.</p>
<h2 id="docker">Docker</h2>
<p>Dockers are a way to package your application and all its dependencies in a single image that can be run on any machine.
The file <code>Dockerfile</code> contains the instructions to build a docker image that will run your application.<br />
Build the image with the following command:</p>
<pre><code class="language-bash">sudo docker build -t mnist-flask-app .
</code></pre>
<p>This will create a docker image named <code>mnist-flask-app</code>.
A docker image is a read-only template that contains a set of instructions for creating a container that can run on the Docker platform.
A docker container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI.
Run the container with the following command:</p>
<pre><code class="language-bash">sudo docker run -p 5000:5000 mnist-flask-app
</code></pre>
<p>You can now access your application by going to <code>http://localhost:5000</code> in your browser. </p>
<p>By defult the container will run the command <code>python mnist_app.py --weights_path weights/mnist_net.pth</code> when it starts.
You can override this command by passing it as an argument to the <code>docker run</code> command for instance to run the gradio app you can use the following command:</p>
<pre><code class="language-bash">docker run mnist-flask-app python mnist_gradio.py --weights_path weights/mnist_net.pth
</code></pre>
<p>That's it! You have created a docker image that can be run on any machine that has docker installed.
By doing so, you have created a reproducible environment for your application that can be run on any machine.
This is very useful when you want to deploy your application on a server or in the cloud.</p>
<p>DO NOT FORGET TO DELETE YOUR DOCKER IMAGE AND CONTAINER WHEN YOU ARE DONE.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../javascripts/mathjax.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
